#!/usr/bin/env perl

# Copyright © 2006-2017 Jakub Wilk <jwilk@jwilk.net>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

use strict;
use warnings;

use File::stat qw(stat);
use Pod::Usage qw(pod2usage);
use Getopt::Long qw(:config gnu_getopt no_ignore_case);

our $VERSION = '0.3';
my $id = undef;
my $filename = undef;
my $interval = 60 * 60; # 1h
my $debug = 0;
my $fail_on_postpone = 0;

my $home = undef;
if (exists $ENV{ELVOKE_HOME})
{
  $home = $ENV{ELVOKE_HOME};
}
elsif (-d "$ENV{HOME}/.elvoke/")
{
  $home = "$ENV{HOME}/.elvoke/";
}
else
{
  # XDG Base Directory
  require File::BaseDir;
  require File::Path;
  $home = File::BaseDir::cache_home('elvoke/');
  File::Path::make_path($home, { mode => 0700 });
}

sub debug($) { printf STDERR "%s\n", shift if $debug; };

sub error($) { printf STDERR "%s\n", shift; exit -1; }

sub set_id($$)
{
  ($_, $_) = @_;
  pod2usage(-1) unless /^\w{6,}$/;
  $id = $_;
  $filename = "$id.stamp";
}

sub set_filename($$)
{
  $id = undef;
  ($_, $filename) = @_;
}

sub set_interval($$)
{
  ($_, $_) = @_;
  $interval = 0;
  pod2usage(-1) unless /^([0-9]+[dhms])+$/;
  while (/([0-9]+)([dhms])/g)
  {
    my $dt = int($1);
    $dt *= 24 * 60 * 60 if $2 eq 'd';
    $dt *=      60 * 60 if $2 eq 'h';
    $dt *=           60 if $2 eq 'm';
    $interval += $dt;
  }
}

sub compute_digest(@)
{
  require Digest::MD5;
  my $data = join "\0", @_;
  $_ = Digest::MD5::md5_base64($data);
  s/\W/_/g;
  return $_;
}

sub show_version()
{
  print "elvoke $VERSION\n";
  exit 0;
}

sub quote($)
{
  ($_) = @_;
  s/\a/\\a/g; s/\f/\\f/g;
  s/\n/\\n/g; s/\r/\\r/g; s/\t/\\t/g;
  s/\0/\\0/g;
  s/([\0-\x1F])/sprintf '\\x%02X', ord($1)/ge;
  s/'/\\'/g;
  return "'$_'";
}

GetOptions(
  'id|i=s'            => \&set_id,
  'filename|f=s'      => \&set_filename,
  'interval|t=s'      => \&set_interval,
  'fail-on-postpone'  => \$fail_on_postpone,
  'debug'             => \$debug,
  'version'           => \&show_version,
  'help|h|?'          => sub { pod2usage(0); }
) or pod2usage(-1);
pod2usage(-1) if $#ARGV < 0;

my $ex;
$ex = chdir if $home eq '';
$ex = chdir $home if $home ne '';
error q(Can't change working directory to ) . quote($home) . ": $!" unless $ex;

set_id undef, (compute_digest @ARGV) unless defined $filename;
debug "Identifier: '$id'" if defined $id;
debug 'File name: ' . quote($filename);
my $need_run = undef;
my $stat = stat $filename;
if (defined $stat)
{
  my $elapsed = time - $stat->mtime;
  $need_run = $elapsed > $interval;
  debug "$elapsed > $interval" if $need_run;
  debug "$elapsed <= $interval" unless $need_run;
}
else
{
  debug 'Timestamp not found';
  $need_run = 1;
}
exit -2 * $fail_on_postpone unless $need_run;
debug 'I will update timestamp';
my $pid = fork;
error "Fork failed: $!" unless defined $pid;
if ($pid == 0)
{
  # child:
  exec { $ARGV[0] } @ARGV or exit -1;
}
else
{
  # parent:
  debug "The child has pid $pid";
  $pid = wait;
  if ($pid < 0)
  {
    error "Wait failed: $!";
  }
  else
  {
    my $ec = $? >> 8;
    if ($ec == 0)
    {
      debug "The child exited successfully";
      open STAMP, '>', $filename or error q(Can't open ) . quote($filename) . ": $!";
      close STAMP;
    }
    else
    {
      debug "The child exited with error code $ec";
    }
    exit $ec;
  }
}


__END__

=head1 NAME

elvoke - run or postpone commands

=head1 SYNOPSIS

elvoke [I<options>] I<commandline>

=head1 DESCRIPTION

B<elvoke> runs the provided command if enough time has elapsed since its
previous execution.

=head1 OPTIONS

=over 4

=item B<-i>, B<--id> I<identifier>

Use the I<identifier> to distinguish between different commands.
The identifier must consist of at least 6 alphanumeric characters.
The default identifier is generated automatically.

=item B<-f>, B<--file> I<file>

Use the I<file> as a stamp.
The default stamp file name is "I<elvoke-home>/I<identifier>.stamp".

=item B<-t>, B<--interval> I<timespec>

Set the minimum interval between invocations of the same command.

I<timespec> syntax:

=over 2

=item I<n>B<d>

I<n> days

=item I<n>B<h>

I<n> hours

=item I<n>B<m>

I<n> minutes

=item I<n>B<s>

I<n> seconds

=back

The default is B<1h> (one hour).

=item B<--fail-on-postpone>

Exit with non-zero code if the command was postponed.

=item B<--debug>

Output some debug information.

=item B<--version>

Display version information and exit.

=item B<-h>, B<-?>, B<--help>

Display help and exit.

=back

=head1 FILES

elvoke stamp directory (I<elvoke-home>) is determined the following way:

=over 2

=item *

use the B<ELVOKE_HOME> environment variable if it is set;

=item *

otherwise, use "I<$HOME>/.elvoke/" if it exists;

=item *

otherwise, use "I<$XDG_CACHE_DIR>/elvoke/" (creating it if needed)
if the environment variable is set and non-empty;

=item *

otherwise, use "I<$HOME>/.cache/elvoke/" (creating it if needed).

=back

=head1 SEE ALSO

L<cron(8)>

=cut

vim:ts=2 sts=2 sw=2 et
