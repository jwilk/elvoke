#!/usr/bin/env perl

# Copyright © 2006-2019 Jakub Wilk <jwilk@jwilk.net>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

no lib '.';  # CVE-2016-1238

use v5.10;

use strict;
use warnings;

use File::stat qw(stat);
use Getopt::Long qw(:config gnu_getopt no_ignore_case);

our $VERSION = '0.4';
my $id = undef;
my $path = undef;
my $interval = 60 * 60;  # 1h
my $debug = 0;
my $fail_on_postpone = 0;

my $home = undef;
if (exists $ENV{ELVOKE_HOME}) {
    $home = $ENV{ELVOKE_HOME};
} elsif (-d "$ENV{HOME}/.elvoke/") {
    $home = "$ENV{HOME}/.elvoke/";
} else {
    # XDG Base Directory
    require File::BaseDir;
    require File::Path;
    $home = File::BaseDir::cache_home('elvoke/');
    File::Path::make_path($home, { mode => 0700 });
}

sub debug {
    return if not $debug;
    printf {*STDERR} "elvoke: debug: %s\n", shift;
};

sub error {
    printf {*STDERR} "elvoke: error: %s\n", shift;
    exit -1;
}

sub set_id
{
    ($_, $_) = @_;
    /^\w{6,}$/ or error 'invalid identifier syntax';
    $id = $_;
}

sub set_path
{
    $id = undef;
    ($_, $path) = @_;
}

sub set_interval
{
    ($_, $_) = @_;
    $interval = 0;
    /^([0-9]+[dhms])+$/ or error 'invalid interval syntax';
    while (/([0-9]+)([dhms])/g) {
        my $dt = int($1);
        $dt *= 24 * 60 * 60 if $2 eq 'd';
        $dt *=      60 * 60 if $2 eq 'h';
        $dt *=           60 if $2 eq 'm';
        $interval += $dt;
    }
}

sub compute_digest
{
    require Digest::MD5;
    my $data = join "\0", @_;
    $_ = Digest::MD5::md5_base64($data);
    s/\W/_/g;
    return $_;
}

sub show_version
{
    print "elvoke $VERSION\n";
    print "+ Perl $^V\n";
    exit 0;
}

my $usage_summary = 'Usage: elvoke [OPTIONS] -- COMMAND [ARGS...]';

sub show_help()
{
    print <<"EOF";
$usage_summary

Options:
  -i, --id IDENT      identifier to distinguish between different commands
  -f, --file FILE     stamp file (default: ELVOKE-HOME/IDENT.stamp)
  -t, --interval INT  minimum interval between invocations of the same command:
                        Nd = N days
                        Nh = N hours
                        Nm = N minutes
                        Ns = N seconds
                      (default: 1 hour)
  --fail-on-postpone  exit with non-zero code when postponing
  --debug             print debug information
  -h, -?, --help      show this help message and exit
  --version           show version information and exit
EOF
    exit 0;
}

sub bad_usage()
{
    print {*STDERR} "$usage_summary\n";
    exit -1;
}

GetOptions(
    'id|i=s' => \&set_id,
    'file|f=s' => \&set_path,
    'interval|t=s' => \&set_interval,
    'fail-on-postpone' => \$fail_on_postpone,
    'debug' => \$debug,
    'version' => \&show_version,
    'help|h|?' => \&show_help,
) or bad_usage();
bad_usage() if $#ARGV < 0;

debug "home: $home";
if (not defined $path) {
    if (not defined $id) {
        $id = compute_digest @ARGV;
    }
    $path = "$home/$id.stamp";
}
debug "identifier: $id" if defined $id;
debug "stamp path: $path";
my $need_run = undef;
my $stat = stat $path;
if (defined $stat) {
    my $elapsed = time - $stat->mtime;
    $need_run = $elapsed > $interval;
    debug "$elapsed > $interval" if $need_run;
    debug "$elapsed <= $interval" unless $need_run;
} else {
    if ($! == $!{ENOENT}) {
        debug 'timestamp not found';
        $need_run = 1;
    } else {
        error "cannot stat $path: $!";
    }
}
exit -2 * $fail_on_postpone unless $need_run;
debug 'will update timestamp';
my $pid = fork;
error "fork failed: $!" unless defined $pid;
if ($pid == 0) {
    # child:
    exec { $ARGV[0] } @ARGV or exit -1;
} else {
    # parent:
    debug "the child has pid $pid";
    $pid = wait;
    if ($pid < 0) {
        error "wait failed: $!";
    } else {
        my $ec;
        if ($? == 0) {
            debug 'the child exited successfully';
            open STAMP, '>', $path or error "cannot open $path: $!";
            close STAMP;
            $ec = 0;
        } else {
            if ($? & 127) {
                my $signo = $? & 127;
                debug "the child was killed by signal $signo";
                $ec = 128 + $signo;
            } else {
                $ec = $? >> 8;
                debug "the child exited with error code $ec";
            }
        }
        exit $ec;
    }
}

# vim:ts=4 sts=4 sw=4 et
